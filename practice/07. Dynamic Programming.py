# 연산속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘을 작성해야 함

# 다이나믹 프로그래밍은 메모리 공간을 약간 더 사용해 연산 속도를 비약적으로 증가시키는 방법으로, 동적 계획법이라고 함
# 항상 다이나믹 프로그래밍을 사용할 수는 없으며, 다음 조건을 만족할 때 사용함
# 1. 큰 문제를 작은 문제로 나눌 수 있음
# 2. 작은 문제에서 구한 정답은 큰 문제에서도 동일함

# 메모이제이션(top_down)
# 다이나믹 프로그래밍을 구현하는 방법 중 하나
# 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법을 의미
# 일명 캐싱(caching) 이라고도 함

# Top-Down  방식 : 큰 문제를 해결하기 위해 작은 문제를 호출
# Bottom-Up 방식 : 작은 문제부터 차근차근 답을 도출하는 방식


# 재귀방식을 이용한 피보나치 수열
# 시간 복잡도를 말하면 O(2^n)의 지수시간이 소요된다고 표현
def fibo_recursive(x):

    if x == 1 or x == 2:
        return 1

    return fibo_recursive(x-1) + fibo_recursive(x-2)

# 피보나치 함수(Fibonacci Function)를 재귀함수로 구현 (Top-Down 다이나믹 프로그래밍)
# 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하는 방식을 이용

# 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화
d = [0] * 100

def fibo_TDN(x):
    if x == 1 or x == 2:
        return 1

    if d[x] != 0:
        return d[x]

    d[x] = fibo_TDN(x-1) + fibo_TDN(x-2)

    return d[x]

# 피보나치 함수(Fibonacci Function)를 Bottom-up으로 구현
# 다이나믹 프로그래밍은 보텀업을 권장
def fibo_BTU(n):
    d = [0] * 100  # 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화
    d[1] = 1
    d[2] = 1

    for i in range(3, n+1):
        d[i] = d[i-1] + d[i-2]

    return d[n]

# 1로 만들기 위한 최소호출 문제
def to_One(n):

    # 점화식 : min(a-1, a//2, a//3, a//5) + 1 =>> +1은 함수호출 횟수
    d = [0] * (n+1)

    for i in range(2, n+1):
        d[i] = d[i-1] + 1

        if i % 2 == 0:
            d[i] = min(d[i], d[i//2] + 1)
        if i % 3 == 0:
            d[i] = min(d[i], d[i//3] + 1)
        if i % 5 == 0:
            d[i] = min(d[i], d[i//5] + 1)

    return d[n]

# 개미 전사 문제
# 식량 창고 개수 - 저장된 식량 개수
# 식량의 최댓값을 구하는 문제이며, 최소한 한 칸 이상 떨어진 곳에 침투해야함
def ant_Warrior(n):

    d = [10001] * (n+1)

    # array = map(int, input().split())
    array = [1, 3, 1, 5]

    d[0] = array[0]
    d[1] = max(array[0], array[1])

    # 점화식 : i = max(i-1, i-2)
    for i in range(2, n):
        d[i] = max(d[i-1], d[i-2] + array[i])

    return d[n-1]

# 바닥공사
# 문제가로의 길이가 N, 세로의 길이가 2인 직사각형 형태의 얇은 바닥이 있다.
# 태일이는 이 얇은 바닥을 1 X 2의 덮개, 2 X 1의 덮개, 2 X 2의 덮개를 이용해 채우고자 한다.
# 이 때 바닥을 채우는 모든 경우의 수를 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 N이 주어진다. (1 ≤ N ≤ 1,000)

# 출력
# 첫째 줄에 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 최솟값을 출력한다.첫째 줄에 2 X N 크기의 바닥을 채우는 방법의 수를 796,796으로 나눈 나머지를 출력한다.

# 경우의 수!!!
# 이 문제도 점화식만 잘 세우면 해결됩니다. 세로의 길이는 고정되어 있으므로, 가로의 길이만 고려하면 됩니다.
# 1. 가로의 길이가 n-1 크기만큼 채워진 경우, 2x1 덮개 하나로만 채울 수 있습니다.
# 2. 가로의 길이가 n-2 크기만큼 채워진 경우, 1x2 덮개 2개를 넣는 경우와 2x2 덮개 1개를 넣는 경우 총 2개의 경우가 생깁니다.
# dp 테이블의 1과 2번째 초기값을 설정해주고, 점화식을 활용하여 for 반복문을 돌려주었습니다
# 점화식은 d[n] = d[n-1] + 2 * d[n-2]이다.

def interior(N):

    d = [0] * (N + 1)

    d[1] = 1
    d[2] = 3

    for i in range(3, N+1):
        d[i] = (d[i-1] + d[i-2] * 2) % 796796

    return d[N]

# 효율적인 화폐의 구성
# # N가지 종류의 화폐가 있다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 한다.
# # 이때 각 종류의 화폐는 몇 개라도 사용할 수 있다
# # 예를 들어 2원, 3원 단위의 화폐가 있을 때는 15원을 만들기 위해 3원을 5개 사용하는 것이 가장 최소한의
# # 화폐 개수이다
# # M원을 만들기 위한 최소한의 화폐 개수를 출력하는 프로그램을 작성하라

# 1 ) 화폐 단위 2
# dp[15] = min(2로 15를 만드는 개수, dp[13] + 1)
# 따라서 2로 15를 만들 수 없기 때문에 dp[13] + 1 = 6이 이 단계에서의 dp[15]값이 되겠다.
# 2 ) 화폐 단위 3
# dp[15] = min(3으로 15를 만드는 개수, dp[12] + 1)
# 따라서 3원 5개로 15를 만들 수 있기 때문에 dp[15]는 최종적으로 5이다.

def Money():
    
    # n = 줄 | m = 화폐가치
    n, m = 2, 15
    array = [2, 3]

    d = [10001] * (m+1)

    d[0] = 0
    for i in range(n):
        for j in range(array[i], m+1):
            d[j] = min(d[j], d[j-array[i]] + 1)

    if d[m] == 10001:
        print(-1)
    else:
        print(d[m])


    return ""

if __name__ == "__main__":
    # print(fibo_recursive(10))
    # print(fibo_TDN(99))
    # print(fibo_BTU(99))
    # print(to_One(26))
    # print(ant_Warrior(4))
    # print(interior(3))
    print(Money())